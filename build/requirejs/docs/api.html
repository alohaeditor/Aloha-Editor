<div id="directory" class="section">
<h1>RequireJS API</h1>

<ul class="index mono">
    <li class="hbox"><a href="#usage">Usage</a><span class="spacer boxFlex"></span><span class="sect">&sect;&sect; 1-1.7</span></li>
        <ul>
            <li class="hbox"><a href="#jsfiles">Load JavaScript Files</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.1</span></li>
            <li class="hbox"><a href="#define">Define a Module</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2</span></li>
            <ul>
                <li class="hbox"><a href="#defsimple">Simple Name/Value Pairs</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.1</span></li>
                <li class="hbox"><a href="#deffunc">Definition Functions</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.2</span></li>
                <li class="hbox"><a href="#defdep">Definition Functions with Dependencies</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.3</span></li>
                <li class="hbox"><a href="#funcmodule">Define a Module as a Function</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.4</span></li>
                <li class="hbox"><a href="#modulename">Define a Module with a name</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.5</span></li>
                <li class="hbox"><a href="#modulenotes">Other Module Notes</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.6</span></li>
                <li class="hbox"><a href="#circular">Circular Dependencies</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.7</span></li>
            </ul>
            <li class="hbox"><a href="#i18n">Define an I18N Bundle</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3</span></li>
            <li class="hbox"><a href="#text">Specify a Text File Dependency</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.4</span></li>
            <li class="hbox"><a href="#jsonp">Specify a JSONP Service Dependency</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.5</span></li>
            <li class="hbox"><a href="#order">Load Scripts in a Specific Order</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.6</span></li>
        </ul>
    <li class="hbox"><a href="#mechanics">Mechanics</a><span class="spacer boxFlex"></span><span class="sect">&sect; 2</span></li>
    <li class="hbox"><a href="#config">Configuration Options</a><span class="spacer boxFlex"></span><span class="sect">&sect; 3</span></li>
    <li class="hbox"><a href="#pageload">Page Load Event Support</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4</span></li>
    <li class="hbox"><a href="#advanced">Advanced Usage</a><span class="spacer boxFlex"></span><span class="sect">&sect;&sect; 5-5.5</span></li>
    <ul>
        <li class="hbox"><a href="#packages">Loading Modules from Packages</a><span class="spacer boxFlex"></span><span class="sect">&sect; 5.1</span></li>
        <li class="hbox"><a href="#multiversion">Multiversion Support</a><span class="spacer boxFlex"></span><span class="sect">&sect; 5.2</span></li>
        <li class="hbox"><a href="#afterload">Loading Code After Page Load</a><span class="spacer boxFlex"></span><span class="sect">&sect; 5.3</span></li>
        <li class="hbox"><a href="#webworker">Web Worker Support</a><span class="spacer boxFlex"></span><span class="sect">&sect; 5.4</span></li>
        <li class="hbox"><a href="#rhino">Rhino Support</a><span class="spacer boxFlex"></span><span class="sect">&sect; 5.5</span></li>
    </ul>
</ul>
</div>

<div class="section">
<h2>
<a name="usage">Usage</a>
<span class="sectionMark">&sect; 1</span>
</h2>

<p>There are 5 basic ways to use require.js:</p>

<ol>
<li>Load JavaScript files.</li>
<li>Define a module that has other dependencies.</li>
<li>Define an internationalization (i18n) bundle.</li>
<li>Specify a text file dependency.</li>
<li>Specify a JSONP service dependency.</li>
</ol>

<h3>
<a name="jsfiles">Load JavaScript Files</a>
<span class="sectionMark">&sect; 1.1</span>
</h3>

<p>If you just want to load some JavaScript files, do the following inside the HEAD tag in an HTML document:</p>

<pre><code>&lt;script src="scripts/require.js"&gt;&lt;/script&gt;
&lt;script&gt;
    require(["some/module", "a.js", "b.js"], function(someModule) {
        //This function will be called when all the dependencies
        //listed above are loaded. Note that this function could
        //be called before the page is loaded.
        //This callback is optional.
    });
&lt;/script&gt;
</code></pre>

<p>The dependencies above, ["some/module", "a.js", "b.js"], will be loaded via script tags that have the following src values:</p>

<ul>
<li>some/module.js</li>
<li>a.js (in the same directory as the HTML page that has the above HTML snippet)</li>
<li>b.js (in the same directory as the HTML page that has the above HTML snippet)</li>
</ul>

<p>Files that end in ".js" are assumed to just be plain JS files that do not use the RequireJS module syntax, and therefore do not use the module-to-path algorithm used for looking up dot-notation modules, like "some/module" above.</p>

<p>See the <a href="#config">Configuration Options</a> section for information on changing the lookup paths used for dependencies.</p>

<p>While you can use require() inside a script tag in an HTML file, it is strongly encouraged to place the work in a file that is loaded by RequireJS. This allows for easier optimization via the optimization tool, and there is a shorthand that can be used in the HTML for this pattern. The above example would be structured like this:</p>

<pre><code>&lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;
</code></pre>

<span class="note">The path rules used for data-main changed in RequireJS 0.23. Before that version, data-main="main" for the above example.</span>

<p>The data-main attribute tells RequireJS to take the value of the data-main attribute and treat it like a require([]) call. So, in this case, it would load scripts/main.js, and that file should have the top-level require call:</p>

<pre><code>//Inside scripts/main.js
require(["some/module", "a.js", "b.js"], function(someModule) {
    //...
});
</code></pre>

<p>The directory that contains the data-main script also then becomes the root URL value (or <strong>baseUrl</strong> in the RequireJS terms) to find other scripts that use the <strong>module naming scheme</strong>, the scheme that does not end a ".js" extension. In this example "some/module" is using the module naming scheme, where "a.js" and "b.js" are not.</p>

<p>Since data-main was used, and main.js is in the scripts directory, the baseUrl for RequireJS becomes the <strong>scripts</strong> directory. The <strong>"some/module"</strong> script would map to a path relative to the scripts directory. So it would be found at <strong>scripts/some/module.js</strong>.</p>

<p>Note how this is different from the first example where "some/module" was found at some/module.js. If data-main is not used and an explicit baseUrl value is not passed in the <a href="#config">RequireJS configuration</a>, then then the default baseUrl is the directory containing the HTML page that loads RequireJS.</p>

<p>Script names that are just regular paths ending in ".js", start with a "/" or have a protocol in them are always mapped relative to the HTML page instead of relative to baseUrl, just like HTML &lt;script&gt; src="" values. You can use the "module naming scheme" even if the script does not define a module, it is just means the path will be relative to baseUrl in that case.</p>

<h3>
<a name="define">Define a Module</a>
<span class="sectionMark">&sect; 1.2</span>
</h3>

<p>A module is different from a traditional script file in that it defines a well-scoped object that avoids polluting the global namespace. It can explicitly list its dependencies and get a handle on those dependencies without needing to refer to global objects, but instead receive the dependencies as arguments to the function that defines the module. Modules in RequireJS are an extension of the <a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth">Module Pattern</a>, with the benefit of not needing globals to refer to other modules.</p>

<p>The RequireJS syntax for modules allows them to be loaded as fast as possible, even out of order, but evaluated in the correct dependency order, and since global variables are not created, it makes it possible to <a href="#multiversion">load multiple versions of a module in a page</a>.</p>

<p>(If you are familiar with or are using CommonJS modules, then please also see <a href="commonjs.html">CommonJS Notes</a> for information on how the RequirejS module format maps to CommonJS modules).</p>

<p>There should only be <strong>one</strong> module definition per file on disk. The modules can be grouped into optimized bundles by the <a href="optimization.html">optimization tool</a>.</p>

<span class="note">Note: As of RequireJS 0.14.3, the function <strong>define()</strong> is preferred to create modules. Previously it was <strong>require.def()</strong>. require.def is still available, but define() is encouraged because it conforms to the <a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">Asynchronous Module Proposal</a>. You are free to continue using require.def() if you only want RequireJS to load the modules, but if you want your code to be potentially interoperable with other Async Module script loaders, you should consider using define(). Any API examples that use define() will work the same if require.def() is used instead.</span>

<div class="subSection">
<h4>
<a name="defsimple">Simple Name/Value Pairs</a>
<span class="sectionMark">&sect; 1.2.1</span>
</h4>

<p>If the module does not have any dependencies, and it is just a collection of name/value pairs, then just pass an object literal to define():</p>

<pre><code>//Inside file my/shirt.js:
define({
    color: "black",
    size: "unisize"
});
</code></pre>
</div>

<div class="subSection">
<h4>
<a name="deffunc">Definition Functions</a>
<span class="sectionMark">&sect; 1.2.2</span>
</h4>

<p>If the module does not have dependencies, but needs to use a function to do some setup work, then define itself, pass a function to define():</p>

<pre><code>//my/shirt.js now does setup work
//before returning its module definition.
define(function () {
    //Do setup work here

    return {
        color: "black",
        size: "unisize"
    }
});
</code></pre>
</div>

<div class="subSection">
<h4><a name="defdep">Definition Functions with Dependencies</a><span class="sectionMark">&sect; 1.2.3</span></h4>

<p>If the module has dependencies, the first argument should be an array of dependency names, and the second argument should be a definition function. The function will be called to define the module once all dependencies have loaded. The function should return an object that defines the module. The dependencies will be passed to the definition function as function arguments, listed in the same order as the order in the dependency array:</p>

<pre><code>//my/shirt.js now has some dependencies, a cart and inventory
//module in the same directory as shirt.js
define(["./cart", "./inventory"], function(cart, inventory) {
        //return an object to define the "my/shirt" module.
        return {
            color: "blue",
            size: "large",
            addToCart: function() {
                inventory.decrement(this);
                cart.add(this);
            }
        }
    }
);
</code></pre>

<p>In this example, a my/shirt module is created. It depends on my/cart and my/inventory. On disk, the files are structured like this:</p>

<ul>
<li>my/cart.js</li>
<li>my/inventory.js</li>
<li>my/shirt.js</li>
</ul>

<p>The function call above specifies two arguments, "cart" and "inventory". These are the modules represented by the "./cart" and "./inventory" module names.</p>

<p>The function is not called until the my/cart and my/inventory modules have been loaded, and the function receives the modules as the "cart" and "inventory" arguments.</p>

<p>Modules that define globals are explicitly discouraged, so that multiple versions of a module can exist in a page at a time (see <strong>Advanced Usage</strong>). Also, the order of the function arguments should match the order of the dependencies.</p>

<p>The return object from the function call defines the "my/shirt" module. By defining modules in this way, "my/shirt" does not exist as a global object.</p>
</div>

<div class="subSection">
<h4><a name="funcmodule">Define a Module as a Function</a><span class="sectionMark">&sect; 1.2.4</span></h4>

<p>Modules do not have to return objects. Any valid return value from a function is allowed. Here is a module that returns a function as its module definition:</p>

<pre><code>//A module definition inside foo/title.js. It uses
//my/cart and my/inventory modules from before,
//but since foo/bar.js is in a different directory than
//the "my" modules, it uses the "my" in the module dependency
//name to find them. The "my" part of the name can be mapped
//to any directory, but by default, it is assumed to be a
//sibling to the "foo" directory.
define(["my/cart", "my/inventory"],
    function(cart, inventory) {
        //return a function to define "foo/title".
        //It gets or sets the window title.
        return function(title) {
            return title ? (window.title = title) :
                   inventory.storeName + ' ' + cart.name;
        }
    }
);
</code></pre>
</div>

<div class="subSection">
<h4><a name="modulename">Define a Module with a Name</a><span class="sectionMark">&sect; 1.2.5</span></h4>

<p>You may encounter some define() calls that include a name for the module as the first argument to define():</p>

<pre><code>    //Explicitly defines the "foo/title" module:
    define("foo/title",
        ["my/cart", "my/inventory"],
        function(cart, inventory) {
            //Define foo/title object in here.
       }
    );
</code></pre>

<p>These are normally generated by the <a href="optimization.html">optimization tool</a>. You can explicitly name modules yourself, but it makes the modules less portable -- if you move the file to another directory you will need to change the name. It is normally best to avoid coding in a name for the module and just let the optimization tool burn in the module names. The optimization tool needs to add the names so that more than one module can be bundled in a file, to allow for faster loading in the browser.</p>
</div>

<div class="subSection">

<h4><a name="modulenotes">Other Module Notes</a><span class="sectionMark">&sect; 1.2.6</span></h4>

<p><strong>One module per file.</strong>: Only one module should be defined per JavaScript file, given the nature of the module name-to-file-path lookup algorithm. Multiple modules will be grouped into optimized files by the <a href="optimization.html">optimization tool</a>, but you should only use the optimization tool to place more than one module in a file.</p>

<p><strong>Relative module names inside define()</strong>: For require("./relative/name") calls that can happen inside a define() function call, be sure to ask for "require" as a dependency, so that the relative name is resolved correctly:</p>

<pre><code>define(["require", "./relative/name"], function(require) {
    var mod = require("./relative/name");
});
</code></pre>

<p>Or better yet, use the shortened syntax that is available for use with <a href="commonjs.html">translating CommonJS</a> modules:</p>

<pre><code>define(function(require) {
    var mod = require("./relative/name");
});
</code></pre>

<p>This form will use Function.prototype.toString() to find the require() calls, and add them to the dependency array, along with "require", so the code will work correctly with relative paths.</p>

<p><strong>Console debugging</strong>: If you need to work with a module you already loaded via a require(["module/name"], function(){}) call in the JavaScript console, then you can use  the require() form that just uses the string name of the module to fetch it:</p>

<pre><code>require("module/name").callSomeFunction()
</code></pre>

<p>Note this only works if "module/name" was previously loaded via the async version of require: require(["module/name"]). If using a relative path, like './module/name', those only work inside define</p>
</div>

<div class="subSection">
<h4><a name="circular">Circular Dependencies</a><span class="sectionMark">&sect; 1.2.7</span></h4>

<p>If you define a circular dependency (A needs B and B needs A), then in this case when B's module function is called, it will get an undefined value for A. B can fetch A later after modules have been defined by using the require() method (be sure to specify require as a dependency so the right context is used to look up A):</p>

<pre><code>//Inside B.js:
define(["require", "A"],
    function(require, a) {
        //"a" in this case will be null if A also asked for B,
        //a circular dependency.
        return function(title) {
            return require("A").doSomething();
        }
    }
);
</code></pre>

<p>Normally you should not need to use require() to fetch a module, but instead rely on the module being passed in to the function as an argument. Circular dependencies are rare, and usually a sign that you might want to rethink the design. However, sometimes they are needed, and in that case, use require() as specified above.</p>

<p>If you are familiar with CommonJS modules, you could instead declare <strong>exports</strong> as a dependency to create an empty object for the module. By doing this on both sides of a circular dependency, you can then safely hold on to the the other module via a function argument.</p>
</div>

<h3><a name="i18n">Define an I18N Bundle</a><span class="sectionMark">&sect; 1.3</span></h3>

<p>Once your web app gets to a certain size and popularity, localizing the strings in the interface and providing other locale-specific information becomes more useful. However, it can be cumbersome to work out a scheme that scales well for supporting multiple locales.</p>

<p>RequireJS allows you to set up a basic module that has localized information without forcing you to provide all locale-specific information up front. It can be added over time, and only strings/values that change between locales can be defined in the locale-specific file.</p>

<p>i18n bundle support is provided by the i18n.js plugin. It is automatically loaded when a module or dependency specifies the i18n! prefix (more info below). <a href="download.html#i18n">Download the plugin</a> and put it in the same directory as your app's main JS file.</p>

<p>To define a bundle, put it in a directory called "nls" -- the i18n! plugin assumes a module name with "nls" in it indicates an i18n bundle. The "nls" marker in the name tells the i18n plugin where to expect the locale directories (they should be immediate children of the nls directory). If you wanted to provide a bundle of color names in your "my" set of modules, create the directory structure like so:</p>

<ul>
<li>my/nls/colors.js</li>
</ul>

<p>The contents of that file should look like so:</p>

<pre><code>//my/nls/colors.js contents:
define({
    "root": {
        "red": "red",
        "blue": "blue",
        "green": "green"
    }
});
</code></pre>

<p>An object literal with a property of "root" defines this module. That is all you have to do to set the stage for later localization work.</p>

<p>You can then use the above module in another module, say, in a my/lamps.js file:</p>

<pre><code>//Contents of my/lamps.js
define(["i18n!my/nls/colors"], function(colors) {
    return {
        testMessage: "The name for red in this locale is: " + colors.red
    }
});
</code></pre>

<p>The my/lamps module has one property called "testMessage" that uses colors.red to show the localized value for the color red.</p>

<p>Later, when you want to add a specific translation to a file, say for the fr-fr locale, change my/nls/colors to look like so:</p>

<pre><code>//Contents of my/nls/colors.js
define({
    "root": {
        "red": "red",
        "blue": "blue",
        "green": "green"
    },
    "fr-fr": true
});
</code></pre>

<p>Then define a file at my/nls/fr-fr/colors.js that has the following contents:</p>

<pre><code>//Contents of my/nls/fr-fr/colors.js
define({
    "red": "rouge",
    "blue": "bleu",
    "green": "vert"
});
</code></pre>

<p>RequireJS will use the browser's navigator.language or navigator.userLanguage property to determine what locale values to use for my/nls/colors, so your app does not have to change. If you prefer to set the locale, you can use the locale: configuration parameter (see the <a href="#config">Configuration options</a> section).</p>

<p><strong>Note</strong> that RequireJS will always use a lowercase version of the locale, to avoid case issues, so all of the directories and files on disk for i18n bundles should use lowercase locales.</p>

<p>RequireJS is also smart enough to pick the right locale bundle, the one that most closely matches the ones provided by my/nls/colors. For instance, if the locale is "en-us", then the "root" bundle will be used. If the locale is "fr-fr-paris" then the "fr-fr" bundle will be used.</p>

<p>RequireJS also combines bundles together, so for instance, if the french bundle was defined like so (omitting a value for red):</p>

<pre><code>//Contents of my/nls/fr-fr/colors.js
define({
    "blue": "bleu",
    "green": "vert"
});
</code></pre>

<p>Then the value for red in "root" will be used. This works for all locale pieces. If all the bundles listed below were defined, then RequireJS will use the values in the following priority order (the one at the top takes the most precedence):</p>

<ul>
<li>my/nls/fr-fr-paris/colors.js</li>
<li>my/nls/fr-fr/colors.js</li>
<li>my/nls/fr/colors.js</li>
<li>my/nls/colors.js</li>
</ul>

<p>If you prefer to not include the root bundle in the top level module, you can define it like a normal locale bundle. In that case, the top level module would look like:</p>

<pre><code>//my/nls/colors.js contents:
define({
    "root": true,
    "fr-fr": true,
    "fr-fr-paris": true
});
</code></pre>

<p>and the root bundle would look like:</p>

<pre><code>//Contents of my/nls/root/colors.js
define({
    "red": "red",
    "blue": "blue",
    "green": "green"
});
</code></pre>

<h3><a name="text">Specify a Text File Dependency</a><span class="sectionMark">&sect; 1.4</span></h3>

<p>It is nice to build HTML using regular HTML tags, instead of building up DOM structures in script. However, there is no good way to embed HTML in a JavaScript file. The best that can be done is using a string of HTML, but that can be hard to manage, particularly for multi-line HTML.</p>

<p>RequireJS has a plugin, text.js, that can help with this issue. It will automatically be loaded if the text! prefix is used for a dependency. <a href="download.html#text">Download the plugin</a> and put it in the same directory as your app's main JS file.</p>

<p>You can specify a text file resource as a dependency like so:</p>

<pre><code>require(["some/module", "text!some/module.html", "text!some/module.css"],
    function(module, html, css) {
        //the html variable will be the text
        //of the some/module.html file
        //the css variable will be the text
        //of the som/module.css file.
    }
);
</code></pre>

<p>Notice the .html and .css suffixes to specify the extension of the file. The "some/module" part of the path will be resolved according to normal module name resolution: it will use the <strong>baseUrl</strong> and <strong>paths</strong> <a href="#config">configuration options</a> to map that name to a path.</p>

<p>For HTML/XML/SVG files, there is another option. You can pass !strip, which strips XML declarations so that external SVG and XML documents can be added to a document without worry. Also, if the string is an HTML document, only the part inside the body tag is returned. Example:</p>

<pre><code>require(["text!some/module.html!strip"],
    function(html) {
        //the html variable will be the text of the
        //some/module.html file, but only the part
        //inside the body tag.
    }
);
</code></pre>

<p>The text files are loaded via asynchronous XMLHttpRequest (XHR) calls, so you can only fetch files from the same domain as the web page.</p>

<p>However, the build system for RequireJS will inline any text! references with the actual text file contents into the modules, so after a build, the modules that have text! dependencies can be used from other domains.</p>

<h3><a name="jsonp">Specify a JSONP Service Dependency</a><span class="sectionMark">&sect; 1.5</span></h3>

<p><a href="http://en.wikipedia.org/wiki/JSON#JSONP">JSONP</a> is a way of calling some services in JavaScript. It works across domains and it is an established approach to calling services that just require an HTTP GET via a script tag.</p>

<p>To use a JSONP service in RequireJS, specify "define" as the callback parameter's value. This means you can get the value of a JSONP URL as if it was a module definition.</p>

<p>Here is an example that calls a twitter API endpoint. In this example, the JSONP callback parameter is called "callback", so "callback=define" tells the API to wrap the JSON response in a "define()" wrapper:</p>

<pre><code>require(["http://search.twitter.com/trends/current.json?callback=define"],
    function (trends) {
        //The trends object will be the API response for the
        //Twitter trends/current API
        console.log(trends);
    }
);
</code></pre>

<p>This use of JSONP should be limited to JSONP services for initial application setup. If the JSONP service times out, it means other modules you define via define() may not get executed, so the error handling is not robust.</p>

<p><strong>Only JSONP return values that are JSON objects are supported</strong>. A JSONP response that is an array, a string or a number will not work.</p>

<p>This functionality should not be used for long-polling JSONP connections -- APIs that deal with real time streaming. Those kinds of APIs should do more script cleanup after receiving each response, and RequireJS will only fetch a JSONP URL once -- subsequent uses of the same URL as a dependency in a require() or define() call will get a cached value.</p>

<p>Errors in loading a JSONP service are normally surfaced via timeouts for the service, since script tag loading does not give much detail into network problems. To detect errors, you can override require.onError() to get errors. The error object passed to the onerror function will contain two properties if it is a timeout issue:</p>

<ul>
<li><strong>requireType</strong>: value will be "timeout"</li>
<li><strong>requireModules</strong>: an array of module names/URLs that timed out. You can find the JSONP service URL in here.</li>
</ul>

<p>Note however that if you get this type of error it probably means other modules you defined via define() did not get executed, and the scripts you want to use may not be available.</p>

<h3><a name="order">Load Scripts in a Specific Order</a><span class="sectionMark">&sect; 1.6</span></h3>

<p>Normally RequireJS loads and evaluates scripts in an undetermined order. However, there are some traditional scripts that depend on being loaded in a specific order. For those cases you can use the <strong>order</strong> plugin. <a href="download.html#order">Download the plugin</a> and put it in the same directory as your app's main JS file. Example usage:</p>

<pre><code>require(["order!one.js", "order!two.js", "order!three.js"], function () {
    //This callback is called after the three scripts finish loading.
});
</code></pre>

<p>Scripts loaded by the <strong>order</strong> plugin will be fetched asynchronously, but evaluated in the order they are passed to require, so it should still perform better with using script tags in the head of an HTML document.</p>

<p>The <strong>order</strong> plugin is best used with traditional scripts, it is not needed for scripts that use define() to define modules. It is possible to mix and match "order!" dependencies with regular dependencies, but only the "order!" ones will be evaluated in relative order to each other. </p>

<p><strong>Note</strong>: the order! plugin only works with JavaScript files that are cacheable by the browser. If the JS file has headers that do not allow the browser to cache the file, then the order of scripts will not be maintained.</p>
</div>

<div class="section">
<h2>
<a name="mechanics">Mechanics</a>
<span class="sectionMark">&sect; 2</span>
</h2>

<p>RequireJS loads each dependency as a script tag, using head.appendChild().</p>

<p>RequireJS waits for all dependencies to load, figures out the right order in which to call the functions that define the modules, then calls the module definition functions in the right order.</p>

<p>Using RequireJS in a server-side JavaScript environment that has synchronous loading should be as easy as redefining require.load(). The build system does this, the require.load method for that environment can be found in build/jslib/requirePatch.js.</p>

<p>In the future, this code may be pulled into the require/ directory as an optional module that you can load in your env to get the right load behavior based on the host environment.</p>
</div>

<div class="section">
<h2>
<a name="config">Configuration Options</a>
<span class="sectionMark">&sect; 3</span>
</h2>

<p>When using require() in the top-level HTML page (or top-level script file that does not define a module), a configuration object can be passed as the first option:</p>

<pre><code>&lt;script type="text/javascript" src="scripts/require.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
  require({
          baseUrl: "/another/path",
          paths: {
              "some": "some/v1.0"
          },
          waitSeconds: 15,
          locale: "fr-fr",
          context: "foo"
      },
      ["some/module", "my/module", "a.js", "b.js"],
      function(someModule, myModule) {
          //This function will be called when all the dependencies
          //listed above are loaded. Note that this function could
          //be called before the page is loaded.
          //This callback is optional.
      }
  );
&lt;/script&gt;
</code></pre>

<p>Also, you can define require to be an object <strong>before</strong> require.js is loaded, and have the values applied. This example specifies some dependencies to load as soon as require.js defines require() and registers a require.ready() callback to be called after require.js defines require.ready():</p>

<pre><code>&lt;script type="text/javascript"&gt;
    var require = {
        deps: ["some/module1", "my/module2", "a.js", "b.js"],
        callback: function(module1, module2) {
            //This function will be called when all the dependencies
            //listed above in deps are loaded. Note that this
            //function could be called before the page is loaded.
            //This callback is optional.
        },
        ready: function() {
            //This function is called once the DOM is ready.
        }
    };
&lt;/script&gt;
&lt;script type="text/javascript" src="scripts/require.js"&gt;&lt;/script&gt;
</code></pre>

<p>Supported configuration options:</p>

<p><strong>baseUrl</strong>: the root path to use for all module lookups. So in the above example, "my/module"'s script tag will have a src="/another/path/my/module.js". baseUrl is <strong>not</strong> used when loading plain .js files, those strings are used as-is, so a.js and b.js will be loaded from the same directory as the HTML page that contains the above snippet.</p>

<p>If no baseUrl is explicitly set in the configuration, the default value will be the location of the HTML page that loads require.js. If a <strong>data-main</strong> attribute is used, that path will become the baseUrl.</p>

<p>The baseUrl can be a URL on a different domain as the page that will load require.js. RequireJS script loading works across domains. The only restriction is on text content loaded by text! plugins: those paths should be on the same domain as the page, at least during development. The optimization tool will inline text! plugin resources so after using the optimization tool, you can use resources that reference text! plugin resources from another domain.</p>

<p><strong>paths</strong>: path mappings for module names not found directly under baseUrl. The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a "/" or has a URL protocol in it ("like http:"). In those cases, the path is determined relative to baseUrl. Using the above sample config, "some/module"'s script tag will be src="/another/path/some/v1.0/module.js". The path that is used for a module name should <strong>not</strong> include the .js extension, since the path mapping could be for a directory. The path mapping code will automatically add the .js extension when mapping the module name to a path.</p>

<p><strong>packagePaths</strong>: configures module name prefixes to map to CommonJS packages. See the <a href="#packages">packages topic</a> for more information. Related to <strong>packages</strong> config option.</p>

<p><strong>packages</strong>: configures loading modules from CommonJS packages. See the <a href="#packages">packages topic</a> for more information. Related to <strong>packagePaths</strong> config option.</p>

<p><strong>waitSeconds</strong>: The number of seconds to wait before giving up on loading a script. The default is 7 seconds.</p>

<p><strong>locale</strong>: The locale to use for loading i18n bundles. By default navigator.language or navigator.userLanguage will be used. The proper syntax for specifying a locale is using lowercase and separating values by dashes, for instance: "fr-fr-paris" or "en-us".</p>

<p><strong>context</strong>: A name to give to a loading context. This allows require.js to load multiple versions of modules in a page, as long as each top-level require call specifies a unique context string. See <strong>Advanced Features</strong> below.</p>

<p><strong>deps</strong>: An array of dependencies to load. Useful when require is defined as a config object before require.js is loaded, and you want to specify dependencies to load as soon as require() is defined.</p>

<p><strong>callback</strong>: A function to pass to require that should be require after <strong>deps</strong> have been loaded. Useful when require is defined as a config object before require.js is loaded, and you want to specify a function to require after the configuration's <strong>deps</strong> array has been loaded.</p>

<p><strong>ready</strong>: A function to pass to require.ready(). Useful when require is defined as a config object before require.js is loaded, and you want to specify a require.ready callback to set as soon as require() is defined.</p>

<p><strong>priority</strong>: An array of module/file names to load immediately, before tracing down any other dependencies. This allows you to set up a small set of files that are downloaded in parallel that contain most of the modules and their dependencies already built in. More information is in the <a href="faq-optimization#priority">Optimization FAQ, Priority Downloads</a>.</p>

<p><strong>urlArgs</strong>: Extra query string arguments appended to URLs that RequireJS uses to fetch resources. Most useful to cache bust when the browser or server is not configured correctly. Example cache bust setting for urlArgs:</p>

<pre><code>urlArgs: "bust=" +  (new Date()).getTime()
</code></pre>

<p>During development it can be useful to use this, however <strong>be sure</strong> to remove it before deploying your code.</p>
</div>

<div class="section">
<h2>
<a name="pageload">Page Load Event Support</a>
<span class="sectionMark">&sect; 4</span>
</h2>

<p>require.js also has a method for notifying your code when the page has loaded. require.js uses the DOMContentLoaded event for browsers that support it, or window onload for browsers that do not.</p>

<p>The syntax:</p>

<pre><code>require.ready(function() {
  //DOM is ready, DOM nodes can be manipulated now.
});
</code></pre>

<p>To use it in conjunction with module loading:</p>

<pre><code>require(["module/one", "module/two"],
    function(one, two) {
      require.ready(function() {
        one.modifyTheDom();
      });
    }
);
</code></pre>
</div>

<div class="section">
<h2>
<a name="advanced">Advanced Usage</a>
<span class="sectionMark">&sect; 5</span>
</h2>

<h3><a name="packages">Loading Modules from Packages</a><span class="sectionMark">&sect; 5.1</span></h3>

<p>RequireJS supports loading modules that are in a <a href="http://wiki.commonjs.org/wiki/Packages/1.1">CommonJS Packages</a> directory structure, but some additional configuration needs to be specified for it to work. Specifically, there is support for the following CommonJS Packages features:</p>

<ul>
<li>A package can be associated with a module name/prefix.</li>
<li>The package config can specify the following properties for a specific package:
<ul>
<li><strong>name</strong>: The name of the package (used for the module name/prefix mapping)</li>
<li><strong>location</strong>: The location on disk. Locations are relative to the baseUrl configuration value, unless they contain a protocol or start with a front slash (/).</li>
<li><strong>lib</strong>: The name of the directory inside the package folder that contains modules. The default value is "lib", so no need to specify it unless it is different than the default.</li>
<li><strong>main</strong>: The name of the module inside the package that should be used when someone does a require for "packageName". The default value is "lib/main", so only specify it if it differs from the default. The value is relative to the package folder.</li>
</ul></li>
</ul>

<p><strong>IMPORTANT NOTES</strong></p>

<ul>
<li>While the packages can have the CommonJS directory layout, the modules themselves should be in a module format that RequireJS can understand. Exception to the rule: if you are using the r.js Node adapter, the modules can be in the traditional CommonJS module format. You can use the <a href="commonjs.html#autoconversion">CommonJS converter tool</a> if you need to convert traditional CommonJS modules into the async module format that RequireJS uses.</li>
<li>Only one version of a package can be used in a project context at a time. You can use RequireJS <a href="#multiversion">multiversion support</a> to load two different module contexts, but if you want to use Package A and B in one context and they depend on different versions of Package C, then that will be a problem. This may change in the future.</li>
</ul>

<p>If you use a similar project layout as specified in the <a href="start.html">Start Guide</a>, the start of your web project would look something like this (Node/Rhino-based projects are similar, just use the contents of the <strong>scripts</strong> directory as the top-level project directory):</p>

<ul>
<li>project-directory/
<ul>
<li>project.html</li>
<li>scripts/
<ul>
<li>require.js</li>
</ul></li>
</ul></li>
</ul>

<p>There are two types of packages you may use in your project -- packages made by other people (third-party packages), and packages that you make as part of your project (source packages). It is suggested that you use two different directories inside scripts to keep track of them. For third-party packages, a <strong>.packages</strong> is recommended, where source packages can just be directories that are siblings to require.js. The third-party packages likely do not need to be committed to your source control, so you can put .packages in your source control's ignore file (.gitignore, .hgignore, etc...).</p>

<p>However, you will want to remember what third-party packages you are using, and where you got them. For that reason, it is suggested that you construct a <strong>package.json</strong> file in the <strong>scripts</strong> directory and use a <a href="http://wiki.commonjs.org/wiki/Packages/Mappings"><strong>mappings</strong></a> section in the package.json file to remember the locations.</p>

<p>Here is how the example directory layout looks with two third-party packages, <strong>alpha</strong> and <strong>omega</strong>, and has two source packages, <strong>cart</strong> and <strong>store</strong>:</p>

<ul>
<li>project-directory/
<ul>
<li>project.html</li>
<li>scripts/
<ul>
<li>.gitignore (ignores .packages)</li>
<li>.packages/
<ul>
<li>alpha/
<ul>
<li>lib/
<ul>
<li>main.js</li>
</ul></li>
</ul></li>
<li>omega/
<ul>
<li>lib/
<ul>
<li>main.js</li>
</ul></li>
</ul></li>
</ul></li>
<li>cart/
<ul>
<li>lib/
<ul>
<li>main.js</li>
</ul></li>
</ul></li>
<li>store/
<ul>
<li>lib/
<ul>
<li>main.js</li>
<li>util.js</li>
</ul></li>
</ul></li>
<li>main.js</li>
<li>package.json</li>
<li>require.js</li>
</ul></li>
</ul></li>
</ul>

<p>The <strong>package.json</strong> for the project might be as simple as this, just to track where alpha and omega came from, since they are not committed to source control:</p>

<pre><code>{
    "mappings": {
        "alpha": "http://example.com/packages/alpha/0.4.zip",
        "omega": "http://example.com/pacakges/omega/1.0.zip"
    }
}
</code></pre>

<p><strong>project.html</strong> will have a script tag like this:</p>

<pre><code>&lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;
</code></pre>

<p>This will instruct require.js to load scripts/main.js. <strong>main.js</strong> uses the <strong>packagePaths</strong> config option to set up the location of the the third party packages, where "packages" is used to set up packages that are relative to require.js, which in this case are the source packages "cart" and "store":</p>

<pre><code>//main.js contents
//Pass a config object to require
require({
    packagePaths: {
        ".packages": ["alpha", "omega"]
    },
    "packages": ["cart", "store"]
});

require(["alpha", "omega", "cart", "store", "store/util"],
function (alpha,   omega,   cart,   store,   util) {
    //use the modules as usual.
});
</code></pre>

<p>A require of "alpha" means that it will be loaded from <strong>scripts/.packages/alpha/lib/main.js</strong>, since "lib" and "main" are the default lib directory and main module settings supported by RequireJS. A require of "store/util" will be loaded from <strong>scripts/store/lib/util.js</strong>.</p>

<p>If the "alpha" and "store" packages did not follow the "lib" and "main.js" conventions, and looked more like this:</p>

<ul>
<li>project-directory/
<ul>
<li>project.html</li>
<li>scripts/
<ul>
<li>.gitignore (ignores .packages)</li>
<li>.packages/
<ul>
<li>alpha/
<ul>
<li>scripts/
<ul>
<li>index.js</li>
</ul></li>
</ul></li>
<li>omega/
<ul>
<li>lib/
<ul>
<li>main.js</li>
</ul></li>
</ul></li>
</ul></li>
<li>cart/
<ul>
<li>lib/
<ul>
<li>main.js</li>
</ul></li>
</ul></li>
<li>store/
<ul>
<li>store.js</li>
<li>util.js</li>
</ul></li>
<li>main.js</li>
<li>package.json</li>
<li>require.js</li>
</ul></li>
</ul></li>
</ul>

<p>Then the RequireJS configuration would look like so:</p>

<pre><code>require({
    packagePaths: {
        ".packages": [
            {
                name: "alpha",
                lib: "scripts",
                main: "index"
            },
            "omega"
        ]
    },
    "packages": [
        "cart",
        {
            name: "store",
            lib: ".",
            main: "store"
        }
    ]
});
</code></pre>

<p><strong>packagePaths</strong> is just a convenience for listing several packages that are not direct siblings of require.js, but still have a common directory parent. The above configuration could be written like so with just the <strong>packages</strong> config option, by using the <strong>location</strong> property for each third-party package:</p>

<pre><code>require({
    "packages": [
        {
            name: "alpha",
            location: ".packages/alpha",
            lib: "scripts",
            main: "index"
        },
        {
            name: "omega",
            location: ".packages/omega"
        }
        "cart",
        {
            name: "store",
            lib: ".",
            main: "store"
        }
    ]
});
</code></pre>

<p>To avoid verbosity, it is strongly suggested to always use packages that use the "lib" and "main" conventions in their structure, and use packagePaths for third party packages.</p>

<p>To make fetching and configuring packages easier, there are designs for a command line package tool in the works.</p>

<h3><a name="multiversion">Multiversion Support</a><span class="sectionMark">&sect; 5.2</span></h3>

<p>As mentioned in <a href="#config">Configuration Options</a>, multiple versions of a module can be loaded in a page by using different "context" configuration options. Here is an example that loads two different versions of the alpha and beta modules (this example is taken from one of the test files):</p>

<pre><code>&lt;script type="text/javascript" src="../require.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
require({
      context: "version1",
      baseUrl: "version1"
    },
    ["require", "alpha", "beta",],
    function(require, alpha, beta) {
      log("alpha version is: " + alpha.version); //prints 1
      log("beta version is: " + beta.version); //prints 1

      setTimeout(function() {
        require(["omega"],
          function(omega) {
            log("version1 omega loaded with version: " +
                omega.version); //prints 1
          }
        );
      }, 100);
    }
);

require({
      context: "version2",
      baseUrl: "version2"
    },
    ["require", "alpha", "beta"],
    function(require, alpha, beta) {
      log("alpha version is: " + alpha.version); //prints 2
      log("beta version is: " + beta.version); //prints 2

      setTimeout(function() {
        require(["omega"],
          function(omega) {
            log("version2 omega loaded with version: " +
                omega.version); //prints 2
          }
        );
      }, 100);
      }
);
&lt;/script&gt;
</code></pre>

<p>Note that "require" is specified as a dependency for the module. This allows the require() function that is passed to the function callback to use the right context to load the modules correctly for multiversion support. If "require" is not specified as a dependency, then there will likely be an error.</p>

<h3><a name="afterload">Loading Code After Page Load</a><span class="sectionMark">&sect; 5.3</span></h3>

<p>The example above in the <strong>Multiversion Support</strong> section shows how code can later be loaded by nested require() calls. </p>

<h3><a name="webworker">Web Worker Support</a><span class="sectionMark">&sect; 5.4</span></h3>

<p>As of release 0.12, RequireJS can be run inside a Web Worker. Just use importScripts() inside a web worker to load require.js (or the JS file that contains the require() definition), then call require.</p>

<p>You will likely need to set the <strong>baseUrl</strong> <a href="#config">configuration option</a> to make sure require() can find the scripts to load.</p>

<p>You can see an example of its use by looking at one of the files used in <a href="http://github.com/jrburke/requirejs/blob/master/tests/workers.js">the unit test</a>.</p>

<h3><a name="rhino">Rhino Support</a><span class="sectionMark">&sect; 5.5</span></h3>

<p>RequireJS can be used in Rhino via the <a href="download.html#node">r.js adapter</a>. Run it like so:</p>

<pre><code>java -jar path/to/rhino/js.jar r.js main.js
</code></pre>

<p>Where main.js has contents that look like this:</p>

<pre><code>//Set up any config values, baseUrl is required so module names
//will map correctly to paths.
require({
    baseUrl: 'path/to/scripts'
});

//Now load the top level script.
require(['startingscript']);
</code></pre>

<p>You can see an example of RequireJS working in Rhino by looking at <a href="http://github.com/jrburke/requirejs/blob/master/adapt/tests/all.js">adapt/tests/all.js</a>.</p>
</div>
